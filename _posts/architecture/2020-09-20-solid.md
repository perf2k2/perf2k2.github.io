---
layout: blog
title:  "Как объяснить SOLID своими словами?"
category: architecture
---

## Как объяснить SOLID своими словами?  
<div class="text-muted small mb-3">20.09.2020</div>

#### Single-responsibility principle 
У класса должна быть только одна обязанность. Например, класс не может читать данные из базы, форматировать их и 
выводить на экран. Это должно быть три разных класса - для чтения данных, для форматирования, и для вывода на экран.

#### Open–closed principle 
Класс должен легко расширяться без изменения его внутренностей (надо проектировать так, чтобы класс можно было 
переиспользовать с обновленной логикой через наследование или реализацию интерфейса). Например, не стоит запихивать 
всю логику в один большой метод - наследнику придется его полностью переписывать. Лучше разделить на более простые 
методы, чтобы наследник мог изменить только пару из них для изменения поведение класса.

#### Liskov substitution principle 
Логически дополняет принцип OCP (предыдущий) - при наследовании метод в исходном классе должен вести себя так же, как 
и до наследования - т.е. не зависеть от реализации других методов исходного класса и не поломать их поведение, при этом 
наследник его тоже не должен поломать. Например, не стоит принимать в метод или возвращать сложный массив данных - 
наследующий класс может не знать о его структуре. Лучше переделать метод на несколько по-меньше или использовать 
отдельный объект для передачи данных.

#### Interface segregation principle 
Лучше иметь несколько маленьких интерфейсов, чем большой общий, который не всеми реализациями используется полностью. 
Необходимо стремиться к тому, чтобы реализации всегда реализовывали все методы интерфейса. Если в какой-то реализации 
приходится ставить заглушку - что-то пошло не так и интерфейс надо делить на более мелкий (при этом один класс может 
реализовать методы нескольких интерфейсов) или вообще изменить подход к проектированию модуля. Этот принцип хорошо 
согласуется с SRP - пример можно взять оттуда.

#### Dependency inversion principle 
Зависимости, от которых зависит класс, должны передаваться только через интерфейсы - чтобы в любой момент можно было 
поменять их реализацию. Например, на боевом окружении реализация интерфейса UserRepository использует базу данных, а на
тестовом - просто хранит данные в оперативной памяти. При этом класс, который зависит от этого интерфейса, менять не 
придется. Следованию этому принципу помогает использование Dependency Injection Container.
